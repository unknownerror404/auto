(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{49:function(n,e,t){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0;var o=[{id:"pages/generated/changelog.md",body:"# `changelog`\n\nPrepend release notes to `CHANGELOG.md`, create one if it doesn't exist, and commit the changes.\n\n## Options\n\n| Flag | Type | Description |\n| - | - | - |\n| `--dry-run`, `-d` | Boolean | Report what command will do but do not actually do anything |\n| `--no-version-prefix` | Boolean | Use the version as the tag without the 'v' prefix |\n| `--name` | String | Git name to commit and release with. Defaults to package definition for the platform |\n| `--email` | String | Git email to commit with. Defaults to package definition for the platform |\n| `--from` | String | Tag to start changelog generation on. Defaults to latest tag. |\n| `--to` | String | Tag to end changelog generation on. Defaults to HEAD. |\n| `--message`, `-m` | String | Message to commit the changelog with. Defaults to 'Update CHANGELOG.md [skip ci]' |\n| `--base-branch` | String | Branch to treat as the \"master\" branch |\n\n## Examples\n\nGenerate a changelog from the last release to head\n\n ```sh\nauto changelog\n```\n\nGenerate a changelog across specific versions\n\n ```sh\nauto changelog --from v0.20.1 --to v0.21.0\n```\n\n\n::: message is-warning\n:warning: This should be run before you version your project so the `CHANGELOG.md` changes are committed before the release gets tagged.\n:::\n\n## Changelog Titles\n\nYou can customize the changelog titles and even add custom ones. To see configuration [go here](/auto/pages/generated/autorc.html#changelog-titles).\n\n## Additional Release notes\n\nSometimes a PR title is just not enough to capture what a user should know about that PR. That's why we've included the ability to put extra release notes right in your PRs. All you have to do is add a `Release Notes` section in your PR.\n\nTake the following PR body:\n\n```md\n# What Changed\n\nChange `shipit` behavior.\n\n## Release Notes\n\n`auto shipit` will only ship to `latest` on the base branch ([which is configurable]()). If ran locally or from a PR it will create a `canary` release that doesn't interfere with your `latest` release.\n```\n\nThis will create a special section at the top of the changelog that collects all the additional release notes from merged PRs. Below is a sample of what it might look like.\n\n---\n\n# v5.0.0 (Sat May 04 2019)\n\n### Release Notes\n\n_From #371_\n\n`auto shipit` will only ship to `latest` on the base branch ([which is configurable]()). If ran locally or from a PR it will create a `canary` release that doesn't interfere with your `latest` release.\n\n---\n\n#### üí• Breaking Change\n\n- shipit will publish a canary locally when not on master [#371](https://github.com/intuit/auto/pull/371) ([@hipstersmoothie](https://github.com/hipstersmoothie))\n\n#### Authors: 1\n\n- Andrew Lisowski ([@hipstersmoothie](https://github.com/hipstersmoothie))\n"},{id:"../plugins/upload-assets/README.md",body:'# Upload Assets Plugin\n\nUpload assets to the release. Good for executables and extra downloadable files.\n\n## Installation\n\nThis plugin is not included with the `auto` CLI installed via NPM. To install:\n\n```sh\nnpm i --save-dev @auto-it/upload-assets\n# or\nyarn add -D @auto-it/upload-assets\n```\n\n## Usage\n\nSimply supply the paths to the assets to add to the release.\n\n```json\n{\n  "plugins": [\n    ["upload-assets", { "assets": ["./path/to/file"] }],\n    // or\n    ["upload-assets", ["./path/to/file"]]\n  ]\n}\n```\n'},{id:"../plugins/twitter/README.md",body:'# Twitter Plugin\n\nPost tweets after a release is made.\n\n## Prerequisites\n\nTo post tweets to twitter you need the following secrets set in your environment:\n\n- `TWITTER_ACCESS_TOKEN`\n- `TWITTER_ACCESS_TOKEN_SECRET`\n- `TWITTER_CONSUMER_KEY`\n- `TWITTER_CONSUMER_KEY_SECRET`\n\n## Installation\n\nThis plugin is not included with the `auto` CLI installed via NPM. To install:\n\n```sh\nnpm i --save-dev @auto-it/twitter\n# or\nyarn add -D @auto-it/twitter\n```\n\n## Usage\n\nSimply supply the names of the account to filter\n\n```json\n{\n  "plugins": [\n    [\n      "twitter",\n      {\n        /* options */\n      }\n    ]\n  ]\n}\n```\n\n## Options\n\n### Message\n\nYou can configure the message posted to twitter. The `message` option should use the following special tokens to create a tweet.\n\n- `%release` - The version bump (major, minor, patch)\n- `%package` - The name of the package\n- `%notes` - Your release notes truncated to fit in the tweet\n- `%link` - A link to your the release on GitHub\n- `%version` - The latest version number\n\nDefault:\n\n```txt\nA new %release version of %package was released!\n\n%notes\n\n%link\n```\n\n```json\n{\n  "plugins": [\n    ["twitter", { "message": "v%version of %package was released!\\n\\n%link" }]\n  ]\n}\n```\n\n### Threshold\n\nBy default the `twitter` plugin will only tweet if the version difference between the latest and the last release is greater than a `minor`.\n\n```json\n{\n  "plugins": [["twitter", { "threshold": "major" }]]\n}\n```\n'},{id:"../plugins/slack/README.md",body:'# Slack Plugin\n\nPost your release notes to a slack channel\n\n## Installation\n\nThis plugin is not included with the `auto` CLI installed via NPM. To install:\n\n```sh\nnpm i --save-dev @auto-it/slack\n# or\nyarn add -D @auto-it/slack\n```\n\n## Usage\n\nTo use the plugin include it in your `.autorc`\n\n```json\n{\n  "plugins": [\n    ["slack", { "url": "https://url-to-your-slack-hook.com" }],\n    // or\n    ["slack", "https://url-to-your-slack-hook.com"],\n    // or\n    [\n      "slack",\n      { "url": "https://url-to-your-slack-hook.com", "atTarget": "here" }\n    ]\n  ]\n}\n```\n\nThis URL should be to you webhook. If you require a token to post to a slack hook, make sure you have a SLACK_TOKEN variable available on your environment. This token will be added to eh URL as a query string parameter.\n'},{id:"../plugins/released/README.md",body:'# Released Plugin\n\nThis plugin\n\n- comments on the merged PR with the new version\n- comments on closed issues with the new version\n- adds a `released` label to the pull request\n- adds a `released` label to closed issues\n\n::: message is-warning\nMake sure that you create the `released` label on you project\n:::\n\n## Installation\n\nThis plugin is included with the `auto` CLI so you do not have to install it. To install if you are using the `auto` API directly:\n\n```sh\nnpm i --save-dev @auto-it/released\n# or\nyarn add -D @auto-it/released\n```\n\n## Usage\n\nTo use the plugin include it in your `.autorc`\n\n```json\n{\n  "plugins": ["npm", "released"]\n}\n```\n\n## Options\n\n### Label\n\nCustomize the label this plugin attaches to merged pull requests.\n\n```json\n{\n  "plugins": [\n    "npm",\n    [\n      "released",\n      {\n        "label": ":shipit:"\n      }\n    ]\n  ]\n}\n```\n\n### Message\n\nTo customize the message this plugin uses on issues and pull requests use the following format.\n\n- `%TYPE` - Either `PR` or `Issue`\n- `%VERSION` - The version that was just published\n\n```json\n{\n  "plugins": [\n    "npm",\n    [\n      "released",\n      {\n        "message": "%TYPE went out with version: %VERSION"\n      }\n    ]\n  ]\n}\n```\n\n### Lock Issue\n\nLock issues that have been merged in PRs.\n\n```json\n{\n  "plugins": ["npm", ["released", { "lockIssues": true }]]\n}\n```\n'},{id:"../plugins/omit-release-notes/README.md",body:'# Omit Release Notes Plugin\n\nFilter PRs with release notes that shouldn\'t make it into a release. By default `auto` will not include and `Release Notes` from [renovate](https://renovatebot.com/) PRs. This plugin allows you to omit more PRs from effecting you releases.\n\n## Installation\n\nThis plugin is not included with the `auto` CLI installed via NPM. To install:\n\n```sh\nnpm i --save-dev @auto-it/omit-release-notes\n# or\nyarn add -D @auto-it/omit-release-notes\n```\n\n## Usage\n\nYarn can omit by most any field available on a PR. Each options accepts either a string or an array of strings.\n\n```json\n{\n  "plugins": [\n    [\n      "omit-release-notes",\n      {\n        // By usernames\n        "username": ["pdbf", "ghost"],\n        // By name\n        "name": "Adam",\n        // By emails\n        "email": ["foo@gmail.com", "doesnt-exits@yahoo.com"],\n        // By labels\n        "labels": "grunt-work"\n      }\n    ]\n  ]\n}\n```\n'},{id:"../plugins/omit-commits/README.md",body:'# Omit Commits Plugin\n\nFilter certain commits out of the changelog and version calculation.\n\n## Installation\n\nThis plugin is not included with the `auto` CLI installed via NPM. To install:\n\n```sh\nnpm i --save-dev @auto-it/omit-commits\n# or\nyarn add -D @auto-it/omit-commits\n```\n\n## Usage\n\nYarn can omit by most any field available on a commit. Each options accepts either a string or an array of strings.\n\n```json\n{\n  "plugins": [\n    [\n      "omit-commits",\n      {\n        // By usernames\n        "username": ["pdbf", "ghost"],\n        // By name\n        "name": "Adam",\n        // By emails\n        "email": ["foo@gmail.com", "doesnt-exits@yahoo.com"],\n        // By presence of string in subject\n        "subject": ["WIP", "SPIKE"],\n        // By labels\n        "labels": "grunt-work"\n      }\n    ]\n  ]\n}\n```\n'},{id:"../plugins/jira/README.md",body:'# Jira Plugin\n\nTo include Jira story information in your changelogs you must include a URL to your hosted JIRA instance.\n\n## Installation\n\nThis plugin is not included with the `auto` CLI installed via NPM. To install:\n\n```sh\nnpm i --save-dev @auto-it/jira\n# or\nyarn add -D @auto-it/jira\n```\n\n## Usage\n\nTo use the plugin include it in your `.autorc`\n\n```json\n{\n  "plugins": [\n    ["jira", { "url": "https://url-to-your-jira.com" }],\n    // or\n    ["jira", "https://url-to-your-jira.com"]\n  ]\n}\n```\n'},{id:"../plugins/first-time-contributor/README.md",body:'# First Time Contributor Plugin\n\nThank first time contributors for their work right in your release notes.\n\n## Installation\n\nThis plugin is not included with the `auto` CLI installed via NPM. To install:\n\n```sh\nnpm i --save-dev @auto-it/first-time-contributor\n# or\nyarn add -D @auto-it/first-time-contributor\n```\n\n## Usage\n\nSimply add the plugins to your auto configuration.\n\n```json\n{\n  "plugins": ["first-time-contributor"]\n}\n```\n'},{id:"../plugins/conventional-commits/README.md",body:'# Conventional Commits Plugin\n\nParse [conventional commit messages](https://www.conventionalcommits.org/en/v1.0.0-beta.4/) and use them to calculate the version. This plugin will omit the PR HEAD if it isn\'t labeled and has a commit with a conventional-commit commit message.\n\n## Installation\n\nThis plugin is not included with the `auto` CLI installed via NPM. To install:\n\n```sh\nnpm i --save-dev @auto-it/conventional-commits\n# or\nyarn add -D @auto-it/conventional-commits\n```\n\n## Usage\n\n```json\n{\n  "plugins": [\n    "conventional-commits"\n    // other plugins\n  ]\n}\n```\n'},{id:"../plugins/s3/README.md",body:'# S3 Plugin\n\nPost your built artifacts to s3.\n\n## Prerequisites\n\nMust have the [aws-cli](https://docs.aws.amazon.com/cli/index.html) on your machine and all of the following environment variables set:\n\n- `AWS_ACCESS_KEY`\n- `AWS_SECRET_KEY`\n- `AWS_SESSION_TOKEN`\n\n## Installation\n\nThis plugin is not included with the `auto` CLI installed via NPM. To install:\n\n```sh\nnpm i --save-dev @auto-it/s3\n# or\nyarn add -D @auto-it/s3\n```\n\n## Usage\n\nPublish a single asset to s3.\n\n`bucket`: Bucket to deploy to\n`region`: Region to deploy to\n`files`: An array of tuples mapping local build files to remote deploy paths.\n\n```txt\nEX:\n\ngiven: `[["components/button/dist", "components/button"]]`\n\n=> Deploy the files in "components/button/dist" to s3://bucket/components/button on `region`\n```\n\n**Full**:\n\n```json\n{\n  "plugins": [\n    [\n      "s3",\n      {\n        "bucket": "BUCKET_NAME",\n        "region": "REGION_NAME",\n        "files": [["components/button/dist", "components/button"]]\n      }\n    ]\n    // other plugins\n  ]\n}\n```\n\n### Versioning Deploys\n\nTo version your deployed assets simply add `$VERSION` in the `remote` path. This will be replaced with the new version being released.\n\n```json\n{\n  "plugins": [\n    [\n      "s3",\n      {\n        "bucket": "BUCKET_NAME",\n        "region": "REGION_NAME",\n        "files": [["components/button/dist", "$VERSION/components/button"]]\n      }\n    ]\n    // other plugins\n  ]\n}\n```\n\n### Multiple Files\n\nPublish multiple assets to s3.\n\n```json\n{\n  "plugins": [\n    [\n      "s3",\n      {\n        "bucket": "BUCKET_NAME",\n        "region": "REGION_NAME",\n        "files": [\n          ["components/button/dist", "components/button"],\n          ["components/card/dist", "components/card"],\n          ["components/select/dist", "components/select"]\n        ]\n      }\n    ]\n  ]\n}\n```\n\n### Multiple Buckets\n\nPublish assets to multiple s3 buckets.\n\n```json\n{\n  "plugins": [\n    [\n      "s3",\n      [\n        {\n          "bucket": "BUCKET_NAME",\n          "region": "REGION_NAME",\n          "files": [["components/button/dist", "components/button"]]\n        },\n        {\n          "bucket": "ANOTHER_BUCKET_NAME",\n          "region": "REGION_NAME",\n          "files": [["components/card/dist", "components/card"]]\n        }\n      ]\n    ]\n  ]\n}\n```\n\n### Overwrite\n\nBy default this plugin will overwrite any bucket path you give it. To prevent it from overwriting your bucket path if it already exists set `overwrite` to false\n\n```json\n{\n  "plugins": [\n    [\n      "s3",\n      {\n        "bucket": "BUCKET_NAME",\n        "region": "REGION_NAME",\n        "overwrite": false,\n        ...\n      }\n    ]\n  ]\n}\n```\n'},{id:"../plugins/all-contributors/README.md",body:'# All Contributors Plugin\n\nAutomatically add contributors as changelogs are produced.\n\nThis plugin maps one of the [contribution type](vhttps://allcontributors.org/docs/en/emoji-key) to a glob or array of globs.\nOut of the box the plugin will only detect the following contribution types:\n\n- üìñ `doc` - Edits to any README, `[\'**/*.mdx\', \'**/*.md\', \'**/docs/**/*\', \'**/documentation/**/*\']``\n- üí° `example` - Edits to `[\'**/*.stories*\', \'**/*.story.*\']`\n- üöá `infra` - Edits to `[\'**/.circle/**/*\', \'**/.github/**/*\', \'**/travis.yml\'],`\n- ‚ö†Ô∏è `test` - Edits to `[\'**/*.test.*\']`\n- üíª `code` - Edits to `[\'**/src/**/*\', \'**/lib/**/*\', \'**/package.json\', \'**/tsconfig.json\']`\n\n## Installation\n\nThis plugin is not included with the `auto` CLI installed via NPM. To install:\n\n```sh\nnpx install-peerdeps --dev @auto-it/all-contributors\n```\n\n## Prerequisites\n\nYou must have already installed and initialized `all-contributors-cli`;\n\n```sh\nnpx all-contributors init\n```\n\n## Usage\n\n```json\n{\n  "plugins": ["all-contributors"]\n}\n```\n\n### Configure Contribution Type Matching\n\nYou use any of the [contribution type](vhttps://allcontributors.org/docs/en/emoji-key).\nIf you configure an pre-configured contribution type the arrays are not merged, it is overridden.\n\n**`auto.rc`**\n\n```json\n{\n  "plugins": [\n    [\n      "all-contributors",\n      {\n        "types": {\n          "plugin": "**/plugin/**/*",\n          "example": ["**/*.stories.*", "**/*.examples.*", "**/*.snippet.*"]\n        }\n      }\n    ]\n  ]\n}\n```\n\n### Exclude Users\n\nUseful for excluding bots from getting into your contributors.\n\n**`auto.rc`**\n\n```json\n{\n  "plugins": [\n    [\n      "all-contributors",\n      {\n        "exclude": ["dependabot", "ci-services"]\n      }\n    ]\n  ]\n}\n```\n'},{id:"../plugins/maven/README.md",body:'# Maven Plugin\n\nRelease a Java project to a [maven](https://maven.apache.org/) instance.\n\n## Installation\n\nThis plugin is not included with the `auto` CLI installed via NPM. To install:\n\n```sh\nnpm i --save-dev @auto-it/maven\n# or\nyarn add -D @auto-it/maven\n```\n\n## Usage\n\n```json\n{\n  "plugins": ["maven"]\n}\n```\n\n## Maven Project Configuration\n\nYour project must be using the maven release plugin. Make sure the the latest `maven-release-plugin` is in your `pom.xml`.\n\n```xml\n<plugin>\n  <groupId>org.apache.maven.plugins</groupId>\n  <artifactId>maven-release-plugin</artifactId>\n  <version>2.5.3</version>\n  <configuration>\n    <preparationGoals>initialize</preparationGoals>\n    <goals>deploy</goals>\n  </configuration>\n</plugin\n```\n\nYou will also need all of the following configuration blocks for all parts of `auto` to function:\n\n1. Author\n\n   ```xml\n   <developers>\n     <developer>\n       <name>Andrew Lisowski</name>\n       <email>test@email.com</email>\n     </developer>\n   </developers>\n   ```\n\n2. SCM\n\n   ```xml\n   <scm>\n     <connection>scm:git:https://github.com/Fuego-Tools/java-test-project.git</connection>\n     <url>https://github.com/Fuego-Tools/java-test-project</url>\n     <tag>HEAD</tag>\n   </scm>\n   ```\n\n3. Version\n\n   ```xml\n   <version>1.0.0-SNAPSHOT</version>\n   ```\n'},{id:"../plugins/npm/README.md",body:'# NPM Plugin\n\nPublish to NPM. Works in both a monorepo setting and for a single package. This plugin is loaded by default when `auto` is installed through `npm`. If you configure `auto` to use any other plugin this will be lost. So you must add the `npm` plugin to your plugins array if you still want NPM functionality.\n\n## Prerequisites\n\nTo publish to npm you will need an `NPM_TOKEN` set in your environment.\n\n## Installation\n\nThis plugin is included with the `auto` CLI so you do not have to install it. To install if you are using the `auto` API directly:\n\n```sh\nnpm i --save-dev @auto-it/npm\n# or\nyarn add -D @auto-it/npm\n```\n\n## Usage\n\n```json\n{\n  "plugins": [\n    "npm",\n    // or with options\n    ["npm", { "forcePublish": false }]\n    // other plugins\n  ]\n}\n```\n\n## Monorepo Usage\n\nThe `npm` plugin works out of the box with `lerna` in both [`independent`](https://github.com/lerna/lerna#independent-mode) and [`fixed`](https://github.com/lerna/lerna#fixedlocked-mode-default) mode. `auto` works on a repo basis and should be run from the root of the repo, not on each sub-package. No additional setup is required.\n\n## Options\n\n### setRcToken\n\nWhen running the `shipit` command auto will try to set your `.npmrc` token while publishing. To disable this feature you must set the `setRcToken` to false.\n\n```json\n{\n  "plugins": [\n    [\n      "npm",\n      {\n        "setRcToken": false\n      }\n    ]\n  ]\n}\n```\n\n### forcePublish\n\nBy default `auto` will force publish all packages for monorepos. To disable this behavior you must set the `setRcToken` to false.\n\n```json\n{\n  "plugins": [\n    [\n      "npm",\n      {\n        "forcePublish": false\n      }\n    ]\n  ]\n}\n```\n\n### subPackageChangelogs\n\n`auto` will create a changelog for each sub-package in a monorepo.\nYou can disable this behavior by using the `subPackageChangelogs` option.\n\n```json\n{\n  "plugins": [\n    [\n      "npm",\n      {\n        "subPackageChangelogs": false\n      }\n    ]\n  ]\n}\n```\n'},{id:"../plugins/git-tag/README.md",body:'# Git Tag Plugin\n\nManage your projects version through just a git tag. This plugin is loaded by default when `auto` is installed through the binaries released on GitHub.\n\nIf you\'re using this plugin you aren\'t releasing your code to any platform (npm, maven, etc). Instead you version calculations is done entirely though git tags.\n\nThis plugin only:\n\n1. gets last git tag\n2. bump it to new version\n3. create new tags\n4. push to github\n\n## Installation\n\nThis plugin is not included with the `auto` CLI installed via NPM. To install:\n\n```sh\nnpm i --save-dev @auto-it/git-tag\n# or\nyarn add -D @auto-it/git-tag\n```\n\n## Usage\n\nSimply add the plugins to your auto configuration.\n\n```json\n{\n  "plugins": ["git-tag"]\n}\n```\n'},{id:"../plugins/crates/README.md",body:'# Crates Plugin\n\nDeploy Rust crates to [crates.io](https://crates.io/).\n\n## Installation\n\nThis plugin is not included with the `auto` CLI installed via NPM. To install:\n\n```sh\nnpm i --save-dev @auto-it/crates\n# or\nyarn add -D @auto-it/crates\n```\n\n## Usage\n\n```json\n{\n  "plugins": ["crates"]\n}\n```\n\n## Crates Project Configuration\n\nThis plugin handles incrementing the crate version, but it requires that your crate be ready for publishing. You can view [the publishing reference](https://doc.rust-lang.org/cargo/reference/publishing.html) for more information on that process.\n\nWhen ran on a machine with `~/cargo/credentials`, that file will automatically be used by Cargo. For machines that do not have this file (like CI builds), the `CARGO_REGISTRY_TOKEN` environment variable is expected for Cargo\'s publish command as per the [publish options](https://doc.rust-lang.org/cargo/commands/cargo-publish.html#cargo_publish_options).\n'},{id:"../plugins/chrome/README.md",body:'# Chrome Web Store\n\nThis plugin allows you to automate the publishing of chrome extensions\n\n::: message is-success\nExample Repo: [here](https://github.com/hipstersmoothie/auto-chrome)\n:::\n\n## Prerequisites\n\nTo publish to the chrome web store you will need the following secrets set in your environment. See [here](https://github.com/DrewML/chrome-webstore-upload/blob/master/How%20to%20generate%20Google%20API%20keys.md) for a guide one how to get these values.\n\n- `CLIENT_ID`\n- `CLIENT_SECRET`\n- `REFRESH_TOKEN`\n\n## Installation\n\nThis plugin is not included with the `auto` CLI installed via NPM. To install:\n\n```sh\nnpm i --save-dev @auto-it/chrome\n# or\nyarn add -D @auto-it/chrome\n```\n\n## Usage\n\nYou must first pack/zip your plugin before running `auto`.\n\nThese environment variables tell `auto` what to publish.\n\n- EXTENSION_ID - your chrome extensions unique ID (REQUIRED)\n- EXTENSION_BUILD - Path to either a zip file, or a directory to be zip. defaults to `extension.zip`\n\nOr you can set these values in the autorc:\n\n```json\n{\n  "plugins": [\n    [\n      "chrome",\n      {\n        "id": "1234",\n        "build": "path/to/zip/or/folder",\n        "manifest": "path/tp/manifest.json"\n      }\n    ]\n  ]\n}\n```\n\n::: message is-warning\n:warning: You must have a manifest.json for this plugin to work.\n:::\n'},{id:"pages/generated/version.md",body:"# `version`\n\nGet the semantic version bump for the given changes. Requires all PRs to have labels for the change type. If a PR does not have a label associated with it, it will default to `patch`.\n\n## Options\n\n| Flag | Type | Description |\n| - | - | - |\n| `--only-publish-with-release-label` | Boolean | Only bump version if 'release' label is on pull request |\n| `--skip-release-labels` | String | Labels that will not create a release. Defaults to just 'skip-release' |\n| `--from` | String | Git revision (tag, commit sha, ...) to calculate version bump from. Defaults to latest github release |\n\n## Examples\n\nGet the new version using the last release to head\n\n ```sh\nauto version\n```\n\nSkip releases with multiple labels\n\n ```sh\nauto version --skip-release-labels documentation CI\n```\n\n\nUseful in conjunction with `npm version` to auto-version releases.\n\n## Prerelease\n\nTo create a prerelease add the `prerelease` label to your pull request.\n\n## Skip Release\n\nTo not create a release for a pull request add the `skip-release` label. Any pull request with this tag will make `auto version` return `''`.\n\n::: message is-warning\n:warning: You must check the return value of `auto version` in a bash script like in the example configuration for the `skip-release` label to function properly.\n:::\n\n### Multiple\n\nYou can configure multiple labels to skip releasing as well. To do this use the `skipReleaseLabels` options. This can also be configured via the [.autorc](/auto/pages/generated/autorc.html#multiple-no-version).\n\n```sh\nauto version --skip-release-labels project-files --skip-release-labels documentation\n```\n\n## Configure Versioning Labels\n\nYou can customize the versioning labels in the `.autorc`. To see configuration [go here](/auto/pages/generated/autorc.html#versioning-labels).\n"},{id:"home.md",body:"::: hero is-primary is-purple is-bold is-medium has-text-centered\n\n# auto release\n\n## CLI tools to help facilitate semantic versioning based on GitHub PR labels\n\n:::\n\n## Adding automated releases shouldn't be hard or require changing your workflow /.no-link .has-text-purple .has-text-centered\\\n\n`auto` makes automating releases for your open source project as simple as labels to pull requests. Releasing often means being confident in your releases. /.has-text-centered\\\n\n||| row has-text-centered wide\n\n::: box\n\n### Release Labels\n\nManaging releases has never been easier. Just add a label!\n:::\n\n::: box\n\n### Beautiful Changelogs\n\nLink to PRs and Jira stories, include authors, monorepo aware, customizable\n:::\n\n::: box\n\n### PR Interaction\n\nSet statuses, check labels and comment on pull requests\n:::\n\n|||\n\n||| row has-text-centered wide\n\n::: box\n\n### Atomic Functions\n\n`auto` functions do 1 thing and they do it well. Easily use them to fit any build process\n:::\n\n::: box\n\n### No Strict Commits\n\nOther tools require you to change how any contributor commits to you project. With `auto` leave that baggage behind!\n:::\n\n::: box\n\n### Fast Workflow\n\nSince all you need to worry about are labels you can work at an incredibly fast pace! This speed to commit also helps with new contributors\n:::\n\n|||\n\n::: hero is-info is-yellow is-small has-text-centered\nRelease Tools\n:::\n\n::::: hero is-small\n:::: div columns\n::: div column feature\n\n# `auto version`\n\nGet the semantic version bump using merged PRs\n\n:::\n::: div column\n![Markdown](images/version.png)\n:::\n::::\n:::::\n\n:::::: hero is-light is-small\n::::: div columns\n::: div column is-three-fifths\n![Markdown](images/changelog.png)\n:::\n:::: div column feature\n\n# `auto changelog`\n\nPrepend release notes to `CHANGELOG.md`.\n\n::: div content list\n\n- link PRs and Jira stories\n- attach effected packages in monorepo\n- list authors\n- customizable sections\n\n:::\n\n::::\n:::::\n::::::\n\n::::: hero is-small\n:::: div columns\n::: div column feature\n\n# `auto release`\n\nAuto-generate a github release.\n\n:::\n::: div column is-three-fifths\n![Markdown](images/release.png)\n:::\n::::\n:::::\n\n::::: hero is-light is-small no-margin\n:::: div columns\n::: div column\n![Markdown](images/shipit.png)\n:::\n::: div column feature\n\n# `auto shipit`\n\nDo all of the above in one simple command!\n:::\n::::\n:::::\n\n::: hero is-red is-link is-small has-text-centered\nPull Request Tools\n:::\n\n:::::: hero is-small\n::::: div columns\n::: div column\n![Markdown](images/pr.png)\n:::\n:::: div column feature\n\n# `auto pr`\n\nSet the status on a PR commit\n\n::::\n:::::\n::::::\n\n::::: hero is-small is-light no-margin\n:::: div columns\n::: div column feature\n\n# `auto comment`\n\nComment on a pull request with a markdown message.\n\n:::\n::: div column\n![Markdown](images/comment.png)\n:::\n::::\n:::::\n\n:::: hero is-link is-purple is-small has-text-centered\n\n# Win back your time and be confident in releasing! /.no-link .title .is-4 .has-text-centered\\\n\n::: button is-large is-link is-bold is-inverted is-outlined\n[Get Started :tada:](/auto/pages/GettingStarted.html)\n:::\n\n::::\n"},{id:"blog/both-worlds.md",body:'---\nimage: https://images.unsplash.com/photo-1554916171-0cfab61e5607?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1200&h=600&fit=crop&ixid=eyJhcHBfaWQiOjF9\ntitle: Best of Both Worlds\nauthor:\n  name: Andrew Lisowski\n  url: https://twitter.com/HipsterSmoothie\n  email: lisowski54@gmail.com\n---\n\nOne of the main goals we had when building auto was to ease the introduction to automated releases through using pull request labels.\n\nThe main alternative to auto works in a slightly different way, [semantic-release](https://github.com/semantic-release/semantic-release) uses the [conventional commit spec](https://www.conventionalcommits.org/en/v1.0.0-beta.4/) to calculate the next version. This is an awesome way to accomplish automated releases, but it is very strict and can create more work when accepting outside contribution. PR labels solve this problem beautifully, but...\n\n![Why not both](https://i.giphy.com/media/cjYH0IhoWiQk8/giphy.webp) /.mediumImage\\\n\nThat\'s exactly why we made the [conventional-commits plugin](). It allows you to keep your conventional commit work flow but still get the benefits of PR labels based automation.\n\nTo start using conventional commit style commit messages simply add the following to your auto config.\n\n```json\n{\n  "plugins": ["conventional-commits"]\n}\n```\n\nNow you can enjoy the best of both worlds! :tada:\n'},{id:"blog/pr-in-progress.md",body:"---\nimage: https://images.unsplash.com/photo-1554520735-0a6b8b6ce8b7?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1200&h=600&fit=crop&ixid=eyJhcHBfaWQiOjF9\ntitle: Merging PRs to other PRs\nauthor:\n  name: Andrew Lisowski\n  url: https://twitter.com/HipsterSmoothie\n  email: lisowski54@gmail.com\n---\n\nSometimes you are working on a big feature and you know it will require a lot of changes. These types of pull requests can be a nightmare to review. Taking in all the changes at once can be overwhelming. It makes it easy to miss smaller mistakes and can make it hard to guess the intent of the changes. Multiple features, bug fixes, or even breaking changes may make up this large PR.\n\nOne way to manage this problem is by making a PR to the large PR. Other contributors can review a smaller subset of changes and also follow along with development. In previous versions of `auto`, large PRs would not be represented well in the changelog and release notes. It would only include the main PR that got merged into master as the only changelog note.\n\nBut thanks to [this PR](https://github.com/intuit/auto/pull/359) that isn't true anymore! Now when you merge one PR to another both changes will be represented in the changelog.\n\n![Clapping](https://i.giphy.com/media/l4HodBpDmoMA5p9bG/200w.webp) /.smallImage\\\n\n_Score!_ /.has-text-centered\\\n\n---\n\nFor example in [PR #351](https://github.com/intuit/auto/pull/351) we changed what happens when you call `shipit` from a PR. Previously if you called `shipit` it would create a new release and publish it to the `latest` tag. The PR made it so `shipit` would create a canary release when run in a PR and only publish to latest from the `master` branch.\n\nAnother [contributor](https://github.com/zephraph) to the project pointed out that some users might not be using `master` as their base branch, so the `baseBranch` should be configurable.\n\nInstead of waiting for #351 to get merged to write the `baseBranch` functionality, I could make a PR to #351 and both PRs would be represented in the changelog!\n\n![Sample release notes](../images/pr-to-pr.png)\n\n---\n\nNow you can be a little more creative with how you manage large PR and have even more detailed changelogs.\n"},{id:"blog/using-shipit.md",body:"---\nimage: https://images.unsplash.com/photo-1556473062-062e556b0920?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1950&q=80\ntitle: Stress-free Continuous Delivery with auto\nauthor:\n  name: Andrew Lisowski\n  url: https://twitter.com/HipsterSmoothie\n  email: lisowski54@gmail.com\n---\n\n`auto` makes releasing your code a breeze. Instead of manually calculating a version and doing your whole release process manually, `auto` takes care of it for you.\n\nThe main command most users use to interact with `auto` is the shipit command. shipit does all the heaving lifting when releasing your code.\n\nWhen run on master it will:\n\n1. Determine if the last merged PR needs to be released\n2. Update a CHANGELOG.md with all you new changes\n3. Publish to NPM\n4. Make a release on GitHub and mark it as latest\n\nWhen run from a PR or locally it will create a canary version.\n\n---\n\n## How does it¬†work?\n\n`auto` does all this magic through GitHub labels. This makes managing outside contribution super easy. Contributors code, you determine the appropriate label, and `auto` takes care of the rest.\n\nThere are a few types of labels:\n\n1. Release Labels\n2. Changelog Labels\n3. Arbitrary labels\n\n---\n\n### Release Labels\n\nThese labels will help you release semantically versioned packages. If no label is present `auto` assumes the PR is a patch.\n\n- major: The PR changes the public API in some way. Create a major release\n- minor: The PR adds a feature to the public API. Create a minor release\n- patch: The PR fixes a bug. Create a patch release\n- skip-release: The PR should not be released. This labels can be used in conjunction with the previous labels for when the PR is actually released\n- internal: Changes only effect how the app is structured or something that doesn't effect the user. This counts as a patch release\n\n### Changelog Labels\n\nThese labels can be used to make your changelogs more expressive. Add them to PRs with release labels to override what changelog section the changes display in. Or use them on their own to just create a patch release.\n\nYou can configure more changelog sections, read more here.\n\n### Arbitrary labels\n\n`auto` doesn't use any extra labels, but you can use whatever labels to power more `auto`mated workflows with `auto` label. This command will return the labels for a PR. Using that information you can choose to run extra CI jobs.\n\nFor example,. the following will only run the test:visual script when the PR has has the Visual label.\n\n```sh\nexport PATH=$(npm bin):$PATH\n\nif [ `auto label --pr $PR_NUMBER | grep -c '^Visual'` -ne 0 ];\nthen\n    npm run test:visual\nfi\n```\n\n---\n\n## Wrapping Up\n\nNow that you know all of the above, you have all you need to release every build as the correct version. No longer worry what tag to publish to or what version. You should never really have to run `auto` yourself, the CI will do that on each build!\n\nAll you have to know is what the labels are and when to use them.\n\nIf you have any questions about how to use `auto` feel free to ask! I hope you guys enjoy the automated release process! :gift:\n"},{id:"blog/why.md",body:"---\nimage: https://cdn-images-1.medium.com/max/800/1*TVSbt7qsyleNiQ84la_log.jpeg\ntitle: Death to Monotony\nauthor:\n  name: Adam Dierkens\n  url: https://github.intuit.com/adierkens\n---\n\n# How auto can ‚Äúhandle the rest for you‚Äù\n\nI‚Äôve been a front-end engineer at Intuit in San Diego for the past three years. As one of three members of Intuit‚Äôs Player team, we are responsible for delivering a JavaScript framework dedicated to rendering most of a user‚Äôs experience in [TurboTax](https://turbotax.intuit.com/). We end up releasing a lot of code, usually React components, quite frequently to our internal node package manager (npm) instance. It‚Äôs not uncommon for us to hit double-digit releases in a single day. This means lots of version bumps, release notes, changelogs, Jira tickets, Slack announcements, and all the other goodies that come with communicating to dependent teams, that their bug is now fixed, or a new feature is ready for them to use. While none of these steps are intrinsically difficult, the time commitment adds up quickly, so we wrote auto: a tool to [auto-generate releases based on semantic version labels](https://github.com/intuit/auto).\n\n---\n\n## The Problem\n\nHistorically, our release process involved a lot of manual labor. Before publishing an update to npm, someone on the team had to gather all of the changes merged since our last release, write up a changelog, and figure out what the next version was going to be. This often involved a lot of back and forth between GitHub and Jira. Once we had all of that, we could create a release, publish it to npm, document it in GitHub, and post an update to our team‚Äôs Slack channel. These 6‚Äì7 monotonous tasks were needed for each release, which easily took up to 30‚Äì60 minutes out of our day.\n\nTo distribute the pain, each month we would nominate someone as the release marshal, who inherited the responsibilities of handling all of the release tasks. It was an inefficient, joyless process that we all resented. Something needed to change.\n\n---\n\n## The Solution\n\nAuto started as a simple Node script that made a few requests to the GitHub API. It gathered the commits merged from the last release and posted those to GitHub. We still had some manual steps in the release process, but it was the start of the end of the monotony.\n\nI brought in another engineer on my team, [Andrew Lisowski](https://www.linkedin.com/in/andrew-lisowski-8b419977/), and we spent the next few months building out the script into a proper npm module. We gave it a well-defined API comprised of small atomic operations that could handle all parts of the release. With auto, the new process is entirely hands-off‚Ää‚Äî‚Ääsimply hit ‚Äúmerge‚Äù, and everything happens automatically.\n\nWe initially crafted auto to solve for our team‚Äôs specific release process‚Ää‚Äî‚Ääwhich needed to post comments and statuses back to a pull request, generate release notes based on what was merged, and document these releases on GitHub and Slack. We eliminated the need for a dedicated release marshal, instead opting for each engineer to annotate their pull requests with a proper semantic version label. Auto would then take it from there, deploying and documenting the release without the need for manual intervention. After dogfooding auto internally for about six months, there was a lot of interest from outside teams, and we knew each of them had slightly different release pipelines, so we worked to make it reusable and customizable for anyone that wanted to use it.\n\nAndrew and I had been talking about using TypeScript for a while and decided that this was a perfect project to start out. By bringing static type-checking to our JavaScript code, refactoring became much less painful, as types quickly caught would-be bugs much sooner. Since writing auto, we‚Äôve made it a point to use TypeScript as our de facto language in any new project we create, including many of the front-end components used in TurboTax today.\n\nInspired by the power and modularity of webpack‚Äôs plugin architecture, we brought in their tap-able module, the core code that powers their plugins. Andrew and I spent about a month slowly refactoring the code to leverage the plugin-based architecture you see today. It went live on [GitHub](https://github.com/intuit/auto) in December 2018 and has since attracted several outside contributors.\n\nAndrew was also getting more involved in the open source community at Intuit, and auto seemed like a great fit for a project to release next‚Ää‚Äî‚Ääany work that we‚Äôd need to do to make auto pluggable for teams inside of Intuit also meant that teams outside of Intuit could leverage it.\n\nWhile a few libraries with similar capabilities already exist, we had yet to identify one that truly met our needs. Packages such as semantic-release were a great inspiration to auto-calculate a version bump based on merged changes, but require a significant change to a developer‚Äôs workflow, something we weren‚Äôt prepared to enforce.\n\nAuto‚Äôs philosophy is to compose each part of the release pipeline into a series of plugins, allowing it to handle a bunch of different use-cases out of the box. Ultimately it boils down to two commands: ‚Äúauto init‚Äù to get started and ‚Äúauto shipit‚Äù to release. Anyone can write a plugin for any part of the release process and add their own custom handlers, without having to change the core system. If instead of publishing to npm, you want to publish an extension to the Chrome Web Store, simply enable that plugin and auto will handle the rest for you.\n\nWe were pleasantly surprised by how quickly auto was picked up by the community. It filled a niche that the existing libraries didn‚Äôt quite cover. By using labels‚Ää‚Äî‚Ääinstead of specially formatted commit messages required by some existing solutions‚Ää‚Äî‚Ääwe were able to significantly lower the barriers to entry for auto. Auto doesn‚Äôt impede the developer workflow‚Ää‚Äî‚Ääjust throw a label on a pull request and continue to focus on code.\n\nWorking on auto from the start has been an amazing experience‚Ää‚Äî‚Äänot only did it help our team, but it‚Äôs awesome to see other teams integrating it into their releases. I‚Äôm really happy that we got to share it with the open source community and am excited to see where the future takes it next.\n"},{id:"pages/troubleshooting.md",body:'# Troubleshooting\n\n## Error: Can\'t find a GitHub token to use\n\nYou must set a `GH_TOKEN` for `auto` to work. Make sure to add your `NPM_TOKEN` while you\'re at it.\n\n## npm ERR! Git working directory not clean\n\nTo version and publish you cannot have any changes in the git repo during publish. This means that if you build some files before release that aren\'t git-ignored `auto` will fail to continue. To fix this either add those `dist` files to your `.gitignore` or commit them somehow before the release.\n\n## npm ERR! need auth auth required for publishing\n\nThis error will occur when you do not have a `NPM_TOKEN` set.\n\n### Still getting errors?!\n\nMake sure that `npm` is trying to publish to the correct registry. Force `npm`/`lerna` to use the public registry by adding the following to your package.json:\n\n```json\n{\n  "publishConfig": {\n    "registry": "https://registry.npmjs.org/",\n    "access": "public"\n  }\n}\n```\n\n## Hangs on: Are you sure you want to continue connecting (yes/no)?\n\nThis mean your environment does not trust github. To change this add this command somewhere before `auto`\n\npublic:\n\n```sh\nmkdir ~/.ssh/ && echo -e "Host github.com\\n\\tStrictHostKeyChecking no\\n" > ~/.ssh/config\n```\n\nenterprise:\n\n```sh\nmkdir ~/.ssh/ && echo -e "Host github.YOUR_COMPANY.com\\n\\tStrictHostKeyChecking no\\n" > ~/.ssh/config\n```\n\n## You cannot publish over the previously published versions\n\nIf you\'ve encountered any of these errors you\'ll probably run into this problem. If the whole release process doesn\'t complete you can end up in a state when `auto` published the new version, but doesn\'t push that back to github. To fix this just bump the version number to the "previously published version".\n\n## Cannot read owner and package name from GitHub URL in package.json\n\nThis means that you do not have a repository set in your package.json. Add something along the line of:\n\n```json\n{\n  "repository": {\n    "type": "git",\n    "url": "https://github.com/intuit/auto"\n  },\n  // or simply\n  "repository": "intuit/auto"\n}\n```\n\n## How do I auto a fork of another repo?\n\nIf auto doesn\'t find a last release it will default to the first commit for version calculation (and a log of other things). If you have forked a repo, you fork all the merge commit messages as well. This confuses `auto` since it will look for those pull requests in your fork and not the main one.\n\nTo remedy this first tag your first commit in the fork with your first version. If the tags from the original repo are still in your repo you should just bump that version. This will let `auto` ignore all the old merge commits.\n\n::: message is-warning\n:warning: You must also match this new tag version in your package.json\n:::\n\n```sh\n# Set head to last release and tag it with 2.10.1\ngit tag v2.10.1\n```\n\nThen on GitHub go to your project, click release, then draft a new release. Select the tag you just published and `publish release`. Now auto will be able to use the correct version and git log!\n'},{id:"pages/build-platforms/github-actions.md",body:'# GitHub Actions\n\nThe following config declares the `release` action that run on all branches. The job will either release:\n\n- a new `latest` version from `master`\n- a `canary` build from a pull request (only on the main fork and if your package manager plugin implements them)\n\n**`.github/workflows/release.yml`**\n\n::: message is-warning\nYou must use some sort of action that implements `skip ci` functionality. Otherwise you will get stuck in a release loop!\n:::\n\n```yaml\nname: Release\n\non: [push]\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v1\n      - name: Skip CI\n        uses: veggiemonk/skip-commit@master\n        env:\n          COMMIT_FILTER: skip ci\n      - name: Prepare repository\n        env:\n          GH_TOKEN: ${{ secrets.GH_TOKEN }}\n        run: |\n          git checkout "${GITHUB_REF:11}" --\n          git remote rm origin\n          git remote add origin "https://$GH_TOKEN@github.com/hipstersmoothie/my-test-project"\n          git fetch origin\n          git branch --set-upstream-to origin/master\n      - name: Use Node.js 12.x\n        uses: actions/setup-node@v1\n        with:\n          node-version: 12.x\n      - name: Create Release\n        env:\n          GH_TOKEN: ${{ secrets.GH_TOKEN }}\n          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}\n        run: |\n          yarn\n          yarn build \n          npx auto shipit\n```\n\n## Troubleshooting\n\nIf you are having problems make sure you have done the following:\n\n- `GH_TOKEN` is set\n- Any other secrets for plugins are set (Ex; `NPM_TOKEN` with the NPM plugin)\n\n## Examples\n\n- [`create-check`](https://github.com/hipstersmoothie/create-check/blob/master/.github/workflows/push.yml)\n- [`octokit-cli`](https://github.com/hipstersmoothie/octokit-cli/blob/master/.github/workflows/push.yml)'},{id:"index.md",body:":tada: Welcome\n\n- [Introduction](/auto/pages/introduction.html)\n- [Getting Started](/auto/pages/getting-started.html)\n- [Merging Quickly](/auto/pages/quick-merge.html)\n\n---\n\n:gear: Configuration\n\n- [.autorc](/auto/pages/autorc.html)\n- [Plugins](/auto/pages/plugins.html)\n- [Non-npm Usage](/auto/pages/non-npm.html)\n- [Writing Plugins](/auto/pages/writing-plugins.html)\n- [Troubleshooting](/auto/pages/troubleshooting.html)\n\n---\n\n:hammer: Tool APIs :wrench:\n\n- [Setup](/auto/pages/generated/init.html)\n  - [auto init](/auto/pages/generated/init.html#init)\n  - [auto create-labels](/auto/pages/generated/init.html#create-labels)\n- [Publishing](/auto/pages/publishing.html)\n  - [auto version](/auto/pages/generated/version.html)\n  - [auto changelog](/auto/pages/generated/changelog.html)\n  - [auto release](/auto/pages/generated/release.html)\n  - [auto shipit](/auto/pages/generated/shipit.html)\n  - [auto canary](/auto/pages/generated/canary.html)\n- [PR Interaction](/auto/pages/pr-interaction.html)\n  - [auto label](/auto/pages/generated/label.html)\n  - [auto pr-status](/auto/pages/generated/pr-status.html)\n  - [auto pr-check](/auto/pages/generated/pr-check.html)\n  - [auto pr-body](/auto/pages/generated/pr-body.html)\n  - [auto comment](/auto/pages/generated/comment.html)\n\n---\n\nPackage Manager Plugins\n\n- [Chrome Web Store](/auto/plugins/chrome/README.html)\n- [Crates](/auto/plugins/crates/README.html)\n- [Git Tag](/auto/plugins/git-tag/README.html)\n- [NPM](/auto/plugins/npm/README.html)\n- [Maven](/auto/plugins/maven/README.html)\n\nFunctionality Plugins\n\n- [All Contributors](/auto/plugins/all-contributors/README.html)\n- [Amazon S3](/auto/plugins/s3/README.html)\n- [Conventional Commits](/auto/plugins/conventional-commits/README.html)\n- [First Time Contributor](/auto/plugins/first-time-contributor/README.html)\n- [Jira](/auto/plugins/jira/README.html)\n- [Omit Commits](/auto/plugins/omit-commits/README.html)\n- [Omit Release Notes](/auto/plugins/omit-release-notes/README.html)\n- [Released](/auto/plugins/released/README.html)\n- [Slack](/auto/plugins/slack/README.html)\n- [Twitter](/auto/plugins/twitter/README.html)\n- [Upload Assets](/auto/plugins/upload-assets/README.html)\n\n---\n\n:bathtub: Continuous Integration\n\n- [CircleCI](/auto/pages/build-platforms/circleci.html)\n- [Travis CI](/auto/pages/build-platforms/travis.html)\n- [GitHub Actions](/auto/pages/build-platforms/github-actions.html)\n- [Jenkins 2](/auto/pages/build-platforms/jenkins.html)\n"},{id:"pages/autorc.md",body:'# `auto` RC File\n\nAll options for the CLI tools can also be configured via the `.autorc`. As CLI options you supply them in snake-case (`--foo-bar`), but as `.autorc` options you supply them in camelCase (`fooBar`),\n\nWe use [cosmiconfig](https://github.com/davidtheclark/cosmiconfig) to find your config. This means you can define this file a variety of ways. Our `cosmiconfig` setup is a little custom and will start at the root of your project and start to search up the directory tree for the following:\n\n- a JSON or YAML, extension-less "rc file"\n- an "rc file" with the extensions `.json`, `.yaml`, or `.yml`\n- a package.json property\n\nWe do not support writing configuration files in JavaScript.\n\n## Initialization\n\nTo interactively create an `.autorc` use the `init` command. You can configure most flags and all labels/changelogTitles.\n\n```sh\nauto init\n```\n\n## Exclusive\n\nThese options can be set exclusively in the `.autorc` and do not exist as CLI flags.\n\n### Extending\n\nIf you want to share your auto configuration between projects you can use the `extends` property. This property will load from a module\'s package.json or from a custom path. It\'s expected that the extended configuration be under the `auto` key in the package.json file.\n\nAuto can load `extends` configs in the following ways:\n\n- from a path `./path/to/config` (this file must be in JSON format)\n- from a scoped package `@YOUR_SCOPE/auto-config` (under the `auto` key in the package.json)\n- from a package `auto-config-YOUR_NAME`\n- from a url `https://yourdomain.com/auto-config.json` (must return the content type `application/json`)\n\n```json\n{\n  "extends": "@YOUR_SCOPE"\n}\n```\n\nWill use the package `@YOUR_SCOPE/auto-config`\n\n```json\n{\n  "extends": "joe"\n}\n```\n\nWill use the package `auto-config-joe`\n\n::: message is-warning\nIf extending from a config package make sure it\'s a dependency of your project\n:::\n\nIf you\'re extending from a local file it can be any file in JSON format or a `package.json` file.\n\n```json\n{\n  "extends": "./path/to/config.json"\n}\n```\n\n```json\n{\n  "extends": "./path/to/other/package.json"\n}\n```\n\n### Labels\n\nTo override any of the default labels use the `labels` section in the `.autorc`.\n\n```json\n{\n  "labels": {\n    "major": "Version: Major",\n    "minor": "Version: Minor",\n    "patch": "Version: Patch",\n    "skip-release": "NO!",\n    "release": "Autobots, rollout!",\n    "prerelease": "beta"\n  }\n}\n```\n\n#### Label Customization\n\nYou can customize everything about a label\n\n- `name` - The label text used for the label. If omitted defaults to the `key` value\n- `title` - The title to use in the changelog\n- `description` - The description to use when creating the label\n- `color` - The color of the label. Can be specified as a string in any of [these](https://github.com/bgrins/TinyColor#accepted-string-input) ways. If not specified the color is random\n\n```json\n{\n  "labels": {\n    "major": {\n      "name": "Version: Major",\n      "title": "The API has changed:",\n      "description": "Add this label to a PR to create a major release",\n      "color": "blue"\n    },\n    ...\n  }\n}\n```\n\n#### Multiple Labels\n\nYou have can multiple labels for each of the default labels.\n\n```json\n{\n  "labels": {\n    "major": [\n      {\n        "name": "BREAKING",\n        "title": "SUPER BREAKING CHANGED",\n      },\n      {\n        "name": "Version: Major",\n        "title": "The API has changed:",\n        "description": "Add this label to a PR to create a major release",\n      }\n    ],\n    ...\n  }\n}\n```\n\n::: message is-warning\n:warning: If you override any of the semantic versioning labels the default values are overridden too! Make sure to include that label if you still want it to be used during version calculation.\n:::\n\n```json\n{\n  "labels": {\n    "minor": [\n      "minor",\n      {\n        "name": "New Component",\n        "title": "üß© New Component",\n        "description": "A new component has been added to the design-system",\n      }\n    ],\n    ...\n  }\n}\n```\n\n#### Changelog Titles\n\nBy default auto will create sections in the changelog for the following labels.\n\n- major\n- minor\n- patch\n- internal\n- documentation\n\nTo customize the title for the section in the changelog you can\n\n```json\n{\n  "labels": {\n    "documentation": {\n      "title": "Docz"\n    },\n    ...\n  }\n}\n```\n\nIf you want more sections in your changelog to further detail the change-set you can\nuse the `labels` section to add more. Any label in the label section with a title\nwill become a special section in your changelog.\n\nThe following adds a `typescript` label to the project that we can use to denote changes\nrelated to a TypeScript re-write.\n\n```json\n{\n  "labels": {\n    "typescript": {\n      "title": "TypeScript Rewrite"\n    },\n    ...\n  }\n}\n```\n\n#### Multiple `skip-release`\n\nYou can configure multiple labels to skip releases.\n\n```json\n{\n  "skipReleaseLabels": ["documentation", "project-files"]\n}\n```\n\n#### Arbitrary Labels\n\nIf you want to `auto create-labels` to add other labels to your project (ones that aren\'t used for\nversioning or the changelog), you can use the `labels` section. Just omit the `title` property.\n\n```json\n{\n  "labels": {\n    "good first issue": {\n      "description": "This is an issue that first time contributors can tackle easily",\n      "color": "purple"\n    },\n    ...\n  }\n}\n```\n\n## CLI args\n\nYou can set any CLI option in the `.autorc` these options will get overridden by the CLI flags.\n\nThe following are options that might be more useful to set in the `.autorc` rather than with a flag.\n\n### Base Branch\n\nConfigure what your repo considers the "master" branch.\n\n```json\n{\n  "baseBranch": "trunk"\n}\n```\n\n### Plugins\n\nIt is useful to specify your plugins in the rc file rather than in all the commands.\n\n```json\n{\n  "plugins": ["npm", "../path/to/plugin.js", "NPM_PACKAGE_NAME"]\n}\n```\n\n### githubApi\n\nIf you are using enterprise github, `auto` lets you configure the github API URL that it uses.\n\n```json\n{\n  "githubApi": "https://github.mine.com/api/v3"\n}\n```\n\n### githubGraphqlApi\n\nThis is used for doing some searches in `auto`.\n\nIf you are using enterprise github and your company hosts the graphql at some other URL than the `githubApi`, you can use `githubGraphqlApi` to set the base path for `auto`. The `githubGraphqlApi` get merged with `/graphql` to build the final URL.\n\n```json\n{\n  "githubGraphqlApi": "https://github.mine.com/api/"\n}\n```\n\n### name\n\nGit name to commit and release with. Used in `auto changelog` and `auto release`\n\n```json\n{\n  "name": "Joe Schmo"\n}\n```\n\n### email\n\nGit email to commit and release with. Used in `auto changelog` and `auto release`\n\n```json\n{\n  "email": "joe@schmo.com"\n}\n```\n'},{id:"pages/build-platforms/circleci.md",body:"# CircleCI\n\nThe following config declares the `release` job and uses it in the `build_and_release` workflow. The `release` job will run at the end of each build and either release:\n\n- a new `latest` version from `master`\n- a `canary` build from a pull request (if your package manager plugin implements them)\n\n```yaml\nversion: 2\n\ndefaults: &defaults\n  working_directory: ~/auto\n  docker:\n    - image: circleci/node:latest-browsers\n\njobs:\n  install: # your install job\n\n  release:\n    <<: *defaults\n    steps:\n      - attach_workspace:\n          at: ~/auto\n      - run:\n          name: Release\n          command: npx auto shipit\n\nworkflows:\n  version: 2\n  build_and_release:\n    jobs:\n      - install\n\n      - release:\n          requires:\n            - install\n```\n\n## Troubleshooting\n\nIf you are having problems make sure you have done the following:\n\n- `GH_TOKEN` is set\n- Any other secrets for plugins are set (Ex; `NPM_TOKEN` with the NPM plugin)\n\n### Problems pushing tags to github\n\nGo to Settings -> Checkout SSH Keys -> `Create and add YOUR_USERNAME user key`. This will create a key with the ability to push to github.\n\n## Examples\n\n- [`auto`](https://github.com/intuit/auto/blob/master/.circleci/config.yml)\n- [`Ignite`](https://github.com/intuit/Ignite/blob/master/.circleci/config.yml)\n- [`reaction`](https://github.com/artsy/reaction/blob/master/.circleci/config.yml)\n"},{id:"pages/publishing.md",body:'# Publishing\n\n`auto`\'s main use it to automate the release process for your project This can be broken down into three core steps:\n\n```text\npre: (optional) Check if new version\n\n1. Generate CHANGELOG.md\n2. Publish code\n3. Generate github release notes\n```\n\n`auto` makes no assumptions about your publishing process. Each tool is a function that can be run in isolation and only does one thing really well. For instance, you could just use `auto changelog` to generate the changelog and nothing else or use `auto version` to calculate just the semver bump.\n\n## Base Branch\n\nBy default `auto` assumes that your repo\'s base branch is `master`. You can configure this behavior through the [.autorc](/auto/pages/autorc.html#base-branch) or via a CLI to any relevant command.\n\n```sh\nauto shipit --base-branch trunk\n```\n\n## Push to base branch\n\nIf you push commits to the base branch they will count as patches. This is a good way to get a release out without having to make a PR.\n\nThe changelog entry will contain the first line of the commit message. These commits will fall under a special section in the changelog.\n\nex:\n\n```md\n‚ö†Ô∏è Pushed to master\n\n- fix docs publishing ([@lisowski54@gmail.com](https://github.com/lisowski54@gmail.com))\n```\n\nYou can configure the title of this changelog entry by adding the `pushToBaseBranch` label in your config.\n\n```json\n{\n  "labels": {\n    "pushToBaseBranch": {\n      "name": "pushToBaseBranch",\n      "title": "Emergency!!"\n    }\n  }\n}\n```\n'},{id:"pages/extras/version.md",body:"Useful in conjunction with `npm version` to auto-version releases.\n\n## Prerelease\n\nTo create a prerelease add the `prerelease` label to your pull request.\n\n## Skip Release\n\nTo not create a release for a pull request add the `skip-release` label. Any pull request with this tag will make `auto version` return `''`.\n\n::: message is-warning\n:warning: You must check the return value of `auto version` in a bash script like in the example configuration for the `skip-release` label to function properly.\n:::\n\n### Multiple\n\nYou can configure multiple labels to skip releasing as well. To do this use the `skipReleaseLabels` options. This can also be configured via the [.autorc](/auto/pages/extras/autorc.html#multiple-no-version).\n\n```sh\nauto version --skip-release-labels project-files --skip-release-labels documentation\n```\n\n## Configure Versioning Labels\n\nYou can customize the versioning labels in the `.autorc`. To see configuration [go here](/auto/pages/extras/autorc.html#versioning-labels).\n"},{id:"pages/build-platforms/travis.md",body:'# Travis CI\n\nThe following config declares the `deploy` job that run on all branches. The job will either release:\n\n- a new `latest` version from `master`\n- a `canary` build from a pull request (if your package manager plugin implements them)\n\n**`.circleci/config.yml`**\n\n```yaml\nlanguage: node_js\nnode_js: \'10\'\nenv:\n  global:\n    - GIT_NAME="Andrew Lisowski"\n    - GIT_EMAIL="lisowski54@gmail.com"\n\nscript:\n  - yarn lint\n  - yarn test\n  - yarn build\n\nbefore_deploy:\n  - git config --local user.name "${GIT_NAME}"\n  - git config --local user.email "${GIT_EMAIL}"\n  - git remote rm origin\n  - git remote add origin https://${GH_TOKEN}@github.com/hipstersmoothie/my-test-project\n  - git fetch origin --tags\n  - git checkout master\n  - git branch --set-upstream-to origin/master master\ndeploy:\n  skip_cleanup: true\n  provider: script\n  script: npx auto shipit\n  on:\n    all_branches: true\n```\n\n## Troubleshooting\n\nIf you are having problems make sure you have done the following:\n\n- `GH_TOKEN` is set\n- Any other secrets for plugins are set (Ex; `NPM_TOKEN` with the NPM plugin)\n\n## Examples\n\n- [`relay-compiler-language-typescript`](https://github.com/relay-tools/relay-compiler-language-typescript/blob/master/.travis.yml)\n'},{id:"pages/extras/changelog.md",body:"::: message is-warning\n:warning: This should be run before you version your project so the `CHANGELOG.md` changes are committed before the release gets tagged.\n:::\n\n## Changelog Titles\n\nYou can customize the changelog titles and even add custom ones. To see configuration [go here](/auto/pages/extras/autorc.html#changelog-titles).\n\n## Additional Release notes\n\nSometimes a PR title is just not enough to capture what a user should know about that PR. That's why we've included the ability to put extra release notes right in your PRs. All you have to do is add a `Release Notes` section in your PR.\n\nTake the following PR body:\n\n```md\n# What Changed\n\nChange `shipit` behavior.\n\n## Release Notes\n\n`auto shipit` will only ship to `latest` on the base branch ([which is configurable]()). If ran locally or from a PR it will create a `canary` release that doesn't interfere with your `latest` release.\n```\n\nThis will create a special section at the top of the changelog that collects all the additional release notes from merged PRs. Below is a sample of what it might look like.\n\n---\n\n# v5.0.0 (Sat May 04 2019)\n\n### Release Notes\n\n_From #371_\n\n`auto shipit` will only ship to `latest` on the base branch ([which is configurable]()). If ran locally or from a PR it will create a `canary` release that doesn't interfere with your `latest` release.\n\n---\n\n#### üí• Breaking Change\n\n- shipit will publish a canary locally when not on master [#371](https://github.com/intuit/auto/pull/371) ([@hipstersmoothie](https://github.com/hipstersmoothie))\n\n#### Authors: 1\n\n- Andrew Lisowski ([@hipstersmoothie](https://github.com/hipstersmoothie))\n"},{id:"pages/extras/label.md",body:"## Using in scripts\n\nThe following will only run the test:visual script when the PR has has the  \n Visual label.\n\n```sh\nexport PATH=$(npm bin):$PATH\n\nif [ auto label --pr $PR_NUMBER | grep -c '^Visual' -ne 0 ];\nthen\n  npm run test:visual\nfi\n```\n\n## Without PR Number\n\nRunning `auto label` without the PR number will:\n\n- When run in master will get the labels for the last merged PR\n- When run for a PR in CI will use the PR's number\n"},{id:"pages/extras/release.md",body:'## Usage\n\n```json\n{\n  "scripts": {\n    "postpublish": "auto release"\n  }\n}\n```\n\nMake sure the branch/tag you\'re releasing is on github before running `auto release`.\nYou will need to push the tags to github first:\n\n```json\n{\n  "scripts": {\n    "postpublish": "git push --follow-tags --set-upstream origin $branch && auto release"\n  }\n}\n```\n'},{id:"pages/build-platforms/jenkins.md",body:"# Jenkins 2\n\nThe following config declares the `release` action that run on all branches. The job will either release:\n\n- a new `latest` version from `master`\n- a `canary` build from a pull request (only on the main fork and if your package manager plugin implements them)\n\n**`Jenkinsfile`**\n\n::: message is-warning\nYou must use some sort of step that implements `skip ci` functionality. Otherwise you will get stuck in a release loop!\n:::\n\n```groovy\n\npipeline {\n  environment {\n    NPM_TOKEN = credentials('NPM_TOKEN')\n    GH_TOKEN = credentials('GH_TOKEN')\n  }\n  stages {\n    stage('Check Skip CI') {\n      steps {\n        script {\n          result = sh (script: \"git log -1 | grep '.*\\\\[skip ci\\\\].*'\", returnStatus: true)\n          if (result == 0) {\n              echo (\"'Skip CI' spotted in git commit. Aborting.\")\n              currentBuild.result = 'ABORTED'\n              error('Exiting job');\n          }\n        }\n      }\n    }\n    stage('Auth') {\n      steps {\n        sh '''\n          echo \"https://${GITHUB_TOKEN}@github.com\" >> /tmp/gitcredfile\n          git config --global user.name \"Andrew Lisowski\"\n          git config --global user.email \"lisowski54@gmail.com\"\n          git config --global credential.helper \"store --file=/tmp/gitcredfile\"\n        '''\n      }\n    }\n    stage('Install') {\n      steps {\n        sh 'yarn install --frozen-lockfile'\n      }\n    }\n    stage('Build') {\n      steps {\n          sh 'yarn build'\n      }\n    }\n    stage('Publish') {\n        when { branch 'master' }\n        steps {\n          sh 'auto shipit'\n        }\n    }\n    stage('Canary') {\n      when { changeRequest() }\n      steps {\n        sh 'auto canary --pr $CHANGE_ID --build $BUILD_NUMBER'\n      }\n    }\n  }\n}\n```\n\n## Troubleshooting\n\nIf you are having problems make sure you have done the following:\n\n- `GH_TOKEN` is set\n- Any other secrets for plugins are set (Ex; `NPM_TOKEN` with the NPM plugin)\n"},{id:"pages/introduction.md",body:"![Markdown](../images/auto.gif)/.header-image\\\n\n# :rocket: auto :rocket:/.has-text-centered\\\n\nAutomated releases powered by pull request labels. Streamline you release workflow and publish constantly! `auto` is meant to be run in a continuous integration (CI) environment, but all the commands work locally as well.\n\nRelease Features:\n\n- Calculate semantic version bumps from PRs\n- Skip a release with the `skip-release` label\n- Publish canary releases from PRs or locally\n- Generate changelogs with fancy headers, authors, and monorepo package association\n- Use labels to create new changelog sections\n- Generate a GitHub release\n\nPull Request Interaction Features:\n\n- Get the labels for a PR\n- Set the status of a PR\n- Check that a pull request has a SemVer label\n- Comment on a PR with markdown\n- Update the PR body with contextual build metadata\n"},{id:"pages/generated/init.md",body:"# Initialization\n\n`auto` provides some tools to quickly set up your project. If you do not want to use the interactive experience all these options can be configured via the [.autorc](/auto/pages/generated/autorc.html) and most can be configure via CLI options.\n\n### `init`\n\nInteractive setup for most configurable options\n\n#### Options\n\n| Flag | Type | Description |\n| - | - | - |\n| `--only-labels` | Boolean | Only run init for the labels. As most other options are for advanced users |\n| `--dry-run`, `-d` | Boolean | Report what command will do but do not actually do anything |\n\n#### Examples\n\n```sh\nauto init\n```\n\n\n### `create-labels`\n\nCreate your project's labels on github. If labels exist it will update them.\n\n#### Options\n\n| Flag | Type | Description |\n| - | - | - |\n| `--dry-run`, `-d` | Boolean | Report what command will do but do not actually do anything |\n\n#### Examples\n\n```sh\nauto create-labels\n```\n\n\n::: message is-warning\n:warning: For this to work you must have a `GH_TOKEN` set, ex: `GH_TOKEN=YOUR_TOKEN auto create-labels`\n:::"},{id:"pages/generated/canary.md",body:"# `canary`\n\nMake a canary release of the project. Useful on PRs. If ran locally, `canary` will release a canary version for your current git HEAD.\n\n1. In PR: 1.2.3-canary.123.0 + add version to PR body\n2. Locally: 1.2.3-canary.1810cfd\n\n## Options\n\n| Flag | Type | Description |\n| - | - | - |\n| `--dry-run`, `-d` | Boolean | Report what command will do but do not actually do anything |\n| `--pr` | Number | PR number to use to create the canary version. Detected in CI env |\n| `--build` | String | Build number to use to create the canary version. Detected in CI env |\n| `--message`, `-m` | String | Message to comment on PR with. Defaults to 'Published PR with canary version: %v'. Pass false to disable the comment |\n\n## Examples\n\n```sh\nauto canary\n```\n\n```sh\nauto canary --pr 123 --build 5\n```\n\n```sh\nauto canary --message \"Install PR version: `yarn add -D my-project@%v`\"\n```\n\n```sh\nauto canary --message false\n```\n\n"},{id:"pages/generated/comment.md",body:'# `comment`\n\nComment on a pull request with a markdown message. Each comment has a context, and each context only has one comment.\n\n## Options\n\n| Flag | Type | Description |\n| - | - | - |\n| `--pr` | Number | The pull request the command should use. Detects PR number in CI |\n| `--context` | String | A string label to differentiate this status from others |\n| `--edit`, `-e` | Boolean | Edit old comment |\n| `--delete` | Boolean | Delete old comment |\n| `--message`, `-m` | String | Message to post to comment |\n| `--dry-run`, `-d` | Boolean | Report what command will do but do not actually do anything |\n\n## Examples\n\n```sh\nauto comment --delete\n```\n\n```sh\nauto comment --pr 123 --message "# Why you\'re wrong..."\n```\n\n```sh\nauto comment --pr 123 --edit --message "This smells..." --context code-smell\n```\n\n'},{id:"pages/quick-merge.md",body:'# Merging Quickly\n\nOne major caveat of `auto` is that you need to be mindful of merging multiple PRs at once. You **must not** merge two PRs at once or you _will_ botch one of the releases.\n\n`auto` works by looking at the `git` tree to calculate the version bump then makes commits for the `CHANGELOG.md` and the new version. If you merge two PRs at once:\n\n1. one might pick up the others changes\n2. they might try to publish the same version number\n3. one will try to push over the other\'s changes and fail\n\n::: message is-success\nIf you ensure that the last build on master has finished you shouldn\'t run into any problems!\n:::\n\n## With `skip-release`\n\nThe one exception to this rule with when merging a bunch of PRs with `skip-release` labels.\n\nYou still can\'t merge a PR that triggers a release and then merge a PR with `skip-release`. This will result in problem 3 from above.\n\n```txt\n1. Merge PR #4 "patch"\n2. Merge PR #5 "skip-release"\n\nResult: #4 tries to push commits over #5 and fails\n```\n\nBut you can merge a bunch of PRs with `skip-release` then merge a PR that triggers a release.\n\n```txt\n1. Merge PR #4 "skip-release"\n2. Merge PR #5 "skip-release"\n3. Merge PR #7 "patch"\n\nResult: 1 "patch" released w/all PRs\n```\n\nBecause `skip-release` is present no commits are made and the release is fine!\n'},{id:"pages/generated/label.md",body:"# `label`\n\nGet the labels for a pull request. Doesn't do much, but the return value lets you write you own scripts based off of the PR labels!\n\n## Options\n\n| Flag | Type | Description |\n| - | - | - |\n| `--pr` | Number | The pull request the command should use. Detects PR number in CI (defaults to last merged PR) |\n\n## Examples\n\n```sh\nauto label --pr 123\n```\n\n\n## Using in scripts\n\nThe following will only run the test:visual script when the PR has has the  \n Visual label.\n\n```sh\nexport PATH=$(npm bin):$PATH\n\nif [ auto label --pr $PR_NUMBER | grep -c '^Visual' -ne 0 ];\nthen\n  npm run test:visual\nfi\n```\n\n## Without PR Number\n\nRunning `auto label` without the PR number will:\n\n- When run in master will get the labels for the last merged PR\n- When run for a PR in CI will use the PR's number\n"},{id:"pages/generated/pr-body.md",body:'# `pr-body`\n\nUpdate the body of a PR with a message. Appends to PR and will not overwrite user content. Each comment has a context, and each context only has one comment.\n\n## Options\n\n| Flag | Type | Description |\n| - | - | - |\n| `--pr` | Number | The pull request the command should use. Detects PR number in CI |\n| `--context` | String | A string label to differentiate this status from others |\n| `--delete` | Boolean | Delete old PR body update |\n| `--message`, `-m` | String | Message to post to PR body |\n| `--dry-run`, `-d` | Boolean | Report what command will do but do not actually do anything |\n\n## Examples\n\n```sh\nauto pr-body --delete\n```\n\n```sh\nauto pr-body --pr 123 --comment "The new version is: 1.2.3"\n```\n\n'},{id:"pages/generated/pr-check.md",body:"# `pr-check`\n\nCheck that a pull request has a SemVer label\n\n## Options\n\n| Flag | Type | Description |\n| - | - | - |\n| `--pr` | Number | The pull request the command should use. Detects PR number in CI |\n| `--url` | String | URL to associate with this status |\n| `--dry-run`, `-d` | Boolean | Report what command will do but do not actually do anything |\n| `--context` | String | A string label to differentiate this status from others |\n| `--skip-release-labels` | String | Labels that will not create a release. Defaults to just 'skip-release' |\n\n## Examples\n\n```sh\nauto pr-check --url http://your-ci.com/build/123\n```\n\n"},{id:"pages/generated/pr-status.md",body:"# `pr-status`\n\nSet the status on a PR commit\n\n## Options\n\n| Flag | Type | Description |\n| - | - | - |\n| `--sha` | String | Specify a custom git sha. Defaults to the HEAD for a git repo in the current repository |\n| `--pr` | Number | PR to set the status on. Detects PR number in CI |\n| `--url` | String | URL to associate with this status |\n| `--state` | String | State of the PR. ['pending', 'success', 'error', 'failure'] |\n| `--description` | String | A description of the status |\n| `--context` | String | A string label to differentiate this status from others |\n| `--dry-run`, `-d` | Boolean | Report what command will do but do not actually do anything |\n\n## Examples\n\n```sh\nauto pr \\\\ \n   --state pending \\\\ \n   --description \"Build still running...\" \\\\ \n   --context build-check\n```\n\n"},{id:"pages/generated/release.md",body:'# `release`\n\nAuto-generate a github release\n\n## Options\n\n| Flag | Type | Description |\n| - | - | - |\n| `--dry-run`, `-d` | Boolean | Report what command will do but do not actually do anything |\n| `--no-version-prefix` | Boolean | Use the version as the tag without the \'v\' prefix |\n| `--name` | String | Git name to commit and release with. Defaults to package definition for the platform |\n| `--email` | String | Git email to commit with. Defaults to package definition for the platform |\n| `--from` | String | Git revision (tag, commit sha, ...) to start release notes from. Defaults to latest tag. |\n| `--use-version` | String | Version number to publish as. Defaults to reading from the package definition for the platform. |\n| `--base-branch` | String | Branch to treat as the "master" branch |\n\n## Examples\n\n```sh\nauto release\n```\n\n```sh\nauto release --from v0.20.1 --use-version v0.21.0\n```\n\n\n## Usage\n\n```json\n{\n  "scripts": {\n    "postpublish": "auto release"\n  }\n}\n```\n\nMake sure the branch/tag you\'re releasing is on github before running `auto release`.\nYou will need to push the tags to github first:\n\n```json\n{\n  "scripts": {\n    "postpublish": "git push --follow-tags --set-upstream origin $branch && auto release"\n  }\n}\n```\n'},{id:"pages/generated/shipit.md",body:'# `shipit`\n\nRun the full `auto` release pipeline. Detects if in a lerna project.\n\n1. call from base branch -> latest version released\n2. call from PR in CI -> canary version released\n3. call locally when not on base branch -> canary version released\n\n## Options\n\n| Flag | Type | Description |\n| - | - | - |\n| `--base-branch` | String | Branch to treat as the "master" branch |\n| `--dry-run`, `-d` | Boolean | Report what command will do but do not actually do anything |\n\n## Examples\n\n```sh\nauto shipit\n```\n\n'},{id:"pages/getting-started.md",body:'# Getting Started\n\nBefore we do anything we must first install `auto` as a dev dependency.\n\n```sh\nyarn add -D auto\n```\n\nIf you are using `auto` in a non-javascript project, you can install `auto` and all it\'s official plugins via the [releases](https://github.com/intuit/auto/releases) page. Here you will find a build of `auto` for all major OSes. This build has `node` bundled so you don\'t need it installed!\n\n## Help\n\nTo get detailed help for any command use the `--help` flag.\n\n```sh\nauto --help\n# or command help\nauto comment --help\n```\n\n## Enterprise\n\nIf you are using enterprise github `auto` lets you configure the github API URL that it uses. You can configure this by using the CLI option `--github-api`, by setting the value in your [.autorc](/auto/pages/autorc.html#githubApi), or during `auto init`.\n\n### Project already published\n\nIf your project is already published then you need to make sure that your last release is tagged and that it\'s the `Latest Release` on GitHub.\n\nTo tag your last release find that last commit where you bumped the version and run the following commands with your version number.\n\n```sh\ngit tag v1.2.3\ngit push --tags\n```\n\nThen on GitHub go to your project\'s releases and click `Draft a new release`. In the `Tag version` field enter the version number you just tagged and click `Publish release`.\n\nNow your github project is set up to use `auto`.\n\n## Configuration\n\nGetting started with `auto` is super easy.\n\n1. `auto init` (optional)\n2. Configure environment variables\n3. `auto create-labels`\n4. Set up script\n\n### 1. Initialize Options\n\nInitialize all options and configure label text. If this is not run then `auto` will use the default configuration. This command will produce and `.autorc`, this contains advanced configuration and might not be needed.\n\n### 2. Environment Variables\n\nYou must configure some environment variables for publishing and releasing to work properly.\n\n- `GH_TOKEN` - Used for updating the changelog and publishing the GitHub release\n- `NPM_TOKEN` - Used to publish to npm. (only with NPM plugin)\n\n#### Local `.env`\n\nYou can also store these values in a local file at the root of your project named `.env`. You should make sure to add this file to your `.gitignore` so you don\'t commit any keys! These env vars will override these any variable already set on the process. This enables you to have a per project configuration that isn\'t effected by your global setup.\n\n**`PROJECT_ROOT/.env`:**\n\n```bash\nGH_TOKEN=YOUR_TOKEN\nNPM_TOKEN=PUBLISH_TOKEN\n```\n\n#### HTTP Proxy\n\nIf you are running auto behind a `http` or `https` proxy, add either the `http_proxy` or `https_proxy` environment variable to your environment. To test locally add it to .env file. Remember this file is only local, so you will need to set the variable in your CI as well.\n\n```bash\nhttps_proxy=<PROXYHOST>:<PROXYPORT>\n```\n\n### 3. Labels\n\nAfter that, you need to set up the labels on your github project. The types of labels that `auto` uses are:\n\n- Versioning Labels - used to calculate version numbers and make releases. To change them refer to [this](/auto/pages/autorc.html#versioning-labels).\n- Changelog Labels - These labels do not effect the version calculation but they will change the section the PR displays in the changelog. These are customizable too, and you can even add your own sections. Read more [here](/auto/pages/autorc.html#changelog-titles)\n\nTo create the labels for your project on GitHub, run the following command with your `GH_TOKEN`.\n\n```sh\nGH_TOKEN=YOUR_TOKEN auto create-labels\n# or with .env file\nauto create-labels\n```\n\n### 4. Script\n\n`auto` is written so that each tool it exposes is useful in isolation. It also provides workflows for those who don\'t care about the details of each tool and just want their code released.\n\n#### Quick Setup\n\nTo version, changelog, publish and release your code all at the same time, we\'ve included the `shipit` tool. This tool takes the default `auto` workflow and puts it into one command.\n\nIt will:\n\n1. Publish canary releases when run from a PR or locally on any branch other than the `baseBranch`\n2. Generate a changelog and publish a "latest" release to a package manager when run from the `baseBranch`\n\n```json\n{\n  "scripts": {\n    "release": "auto shipit"\n  }\n}\n```\n\n#### Detailed Setup\n\nThe simplest workflow to get set up in just the `package.json` is by adding the following to your `package.json`. With this setup your application will not be able to use the `skip-release` flag, but everything else will work just fine\n\n```json\n{\n  "scripts": {\n    "version": "npm version `auto version` -m \'Bump version to: %s [skip ci]\'",\n    "publish": "npm publish && git push --follow-tags --set-upstream origin $branch",\n    "release": "auto changelog && npm run version && npm run publish && auto release"\n  }\n}\n```\n\n##### Enabling `skip-release` label\n\nTo use the `skip-release` label you have to get a little more involved and use a shell script. We could do the `if` checks in the `package.json`, but this would get messy and hard to read very quickly.\n\n```json\n{\n  "scripts": {\n    "release": "./scripts/release.sh"\n  }\n}\n```\n\nHere is an example release script for a single NPM package:\n\n```sh\nexport PATH=$(npm bin):$PATH\n\nVERSION=`auto version`\n\n## Support for label \'skip-release\'\nif [ ! -z "$VERSION" ]; then\n  ## Update Changelog\n  auto changelog\n\n  ## Publish Package\n  npm version $VERSION -m "Bump version to: %s [skip ci]"\n  npm publish\n\n  ## Create GitHub Release\n  git push --follow-tags --set-upstream origin $branch\n  auto release\nfi\n```\n\nor if you are using lerna to manage a monorepo.\n\n```sh\nexport PATH=$(npm bin):$PATH\n\nVERSION=`auto version`\n\nif [ ! -z "$VERSION" ]; then\n  auto changelog\n  lerna publish --yes $VERSION -m \'%v [skip ci]\'\n  auto release\nfi\n```\n'},{id:"pages/non-npm.md",body:'# Non-npm Usage\n\n`auto` by distributed through [npm](https://npmjs.com) but you can use it with a variety of package management platforms.\n\n## Installation\n\nIf you\'re on some platform other than [npm](https://npmjs.com) it doesn\'t make sense to download `auto` through [npm](https://npmjs.com). For these situations we package `auto` for all major operating systems (`linux`, `osx`, `windows`).\n\nSimply download the appropriate version for your operating system and make it executable.\n\n```sh\n# Download a platform specific version of auto\ncurl -vkL -o - https://github.com/intuit/auto/releases/download/v7.2.0/auto-linux.gz | gunzip > ~/auto\n# Make auto executable\nchmod a+x ~/auto\n```\n\nThis executable contains all of the official `auto` plugins so you do not have to download anything extra. This version of `auto` uses the [git-tag](/auto/plugins/git-tag/README.html) plugins as the default instead of [npm](/auto/plugins/npm/README.html). If you specify any plugins this will be overriden.\n\n### Installation via brew (OSX)\n\nIf you are on OSX you can install `auto` with brew.\n\n```sh\nbrew tap intuit/auto https://github.com/intuit/auto\nbrew install auto\n```\n\n## Configuration\n\nUsing `auto` with any other package manager than [npm](https://npmjs.com) requires that you create an [`.autorc`](/auto/pages/autorc.html) at the root of your project.\n\n1. `.autorc` - No plugins, `shipit` doesn\'t work. Enables [advanced setup](https://intuit.github.io/auto/pages/getting-started.html#detailed-setup)\n\n   ```json\n   {\n     "repo": "my-project",\n     "owner": "hipstersmoothie",\n     "name": "Andrew Lisowski",\n     "email": "lisowski54@gmail.com",\n     "plugins": []\n   }\n   ```\n\n2. `.autorc` - `git-tag` plugin compatible with any platform. Enables [`shipit` usage](https://intuit.github.io/auto/pages/generated/shipit.html)\n\n   ```json\n   {\n     "repo": "my-project",\n     "owner": "hipstersmoothie",\n     "name": "Andrew Lisowski",\n     "email": "lisowski54@gmail.com",\n     "plugins": ["git-tag"]\n   }\n   ```\n\n3. `.autorc` - With package manager plugin. [`shipit`](https://intuit.github.io/auto/pages/generated/shipit.html) works, some configuration picked up from package manager package definition files. In the following `repo`, `owner`, `name`, and `email` are picked up from the `pom.xml`\n\n   ```json\n   {\n     "plugins": ["maven"]\n   }\n   ```\n\n## Usage\n\nNow that you have `auto` all set up you can use all of it\'s commands!\n\n```sh\n~/auto shipit\n```\n\n::: message is-info\n‚ÑπÔ∏è Tip: Using `auto` locally with an `.env` file is a great experience. See how [here](./getting-started.md#local-.env).\n:::\n'},{id:"pages/plugins.md",body:'# Plugins\n\n`auto` uses the package [tapable](https://github.com/webpack/tapable) to expose a plugin system.\n\n## Using Plugins\n\nTo use a plugin you can either supply the plugin via a CLI arg or in your [.autorc](/auto/pages/autorc.html#plugins). Specifying a plugin overrides the defaults.\n\n### Defaults\n\nIf you don\'t configure plugins in your `.autorc` configuration file `auto` will use a default package manager plugin.\n\n- Installed through `npm` => uses [`npm`](/auto/plugins/npm/README.html)\n- Installed through executable => uses [`git-tag`](/auto/plugins/git-tag/README.html)\n\n### No Plugins\n\nIf you don\'t want to include the default plugins, you can supply an empty array in the `.autorc` configuration file like the following:\n\n```json\n{\n  "plugins": []\n}\n```\n\nThere are three ways to load a plugin.\n\n### 1. Official Plugins\n\nTo use an official plugin all you have to do is supply the name.\n\n```json\n{\n  "plugins": ["npm"]\n}\n```\n\n### 2. `npm` package\n\nUnofficial plugins pulled from NPM should be named in the format `auto-plugin-PLUGIN_NAME` where `PLUGIN_NAME` is the name of the plugin.\n\nThat name is provided to auto to use that particular plugin.\n\n```json\n{\n  "plugins": ["auto-plugin-my-cool-plugin", "some-package"]\n}\n```\n\n### 3. Path\n\nOr if you have a plugin locally supply the path.\n\n```json\n{\n  "plugins": ["../path/to/plugin.js"]\n}\n```\n\n### Plugin Configuration\n\nTo provide plugin specific config change the following:\n\n```json\n{\n  "plugins": ["chrome"]\n}\n```\n\nTo this:\n\n```json\n{\n  "plugins": [\n    ["chrome", { "extensionId": "1234", "build": "my-compiled-extension.zip" }]\n  ]\n}\n```\n'},{id:"pages/pr-interaction.md",body:"# Pull Request Interaction\n\n`auto` also includes a variety of PR interaction tools to update PRs from the CI. You can use these tools in various ways to make your PR validation process much more customized.\n\n<br />\n\nTools:\n\n:star: [auto-label](/auto/pages/auto-label.html) - Get the labels for a PR\n\n:star: [auto-pr](/auto/pages/auto-pr.html) - Set a status on a PR\n\n:star: [auto-pr-check](/auto/pages/auto-pr-check.html) - Check for a semver label and set a status\n\n:star: [auto-comment](/auto/pages/auto-comment.html) - Comment on a PR\n"},{id:"pages/writing-plugins.md",body:"# Writing Plugins\n\nIf you've ever written a webpack plugin it's a lot like that.\n\nA plugin definition is:\n\n- a class the has an `apply` function where a plugin hooks into various functions in auto (REQUIRED)\n- a constructor where you can load plugin specific config\n\n```ts\nimport { Auto, IPlugin } from 'auto';\n\nexport default class TestPlugin implements IPlugin {\n  private readonly config: any;\n\n  constructor(config: any) {\n    this.config = config;\n  }\n\n  apply(auto: Auto) {\n    // hook into auto\n  }\n}\n```\n\n## Constructor\n\nIn the constructor you have access to any plugin specific config provided in the `.autorc`. It might be useful to write a more type-safe interface for your config.\n\n```ts\nimport { Auto, IPlugin } from 'auto';\n\ninterface ITestPluginConfig {\n  foo?: string;\n  bar?: boolean;\n}\n\nexport default class TestPlugin implements IPlugin {\n  private readonly config: ITestPluginConfig;\n\n  constructor(config: ITestPluginConfig) {\n    this.config = config;\n  }\n}\n```\n\n## Hooks\n\nPlugins work by hooking into various actions that `auto` has to do in order to facilitate a release or interact with your GitHub repo. The hooks that it exposes are:\n\n---\n\n### Main Hooks\n\n#### beforeRun\n\nHappens before anything is done. This is a great place to check for platform specific secrets such as a npm token.\n\n```ts\nauto.hooks.beforeRun.tapPromise('NPM', async config => {\n  if (!process.env.NPM_TOKEN) {\n    auto.logger.log.warn('NPM Token is needed for the NPM plugin!');\n  }\n});\n```\n\n#### modifyConfig\n\nModify what is in the config. You must return the config in this hook.\n\n```ts\nauto.hooks.modifyConfig.tap('test', config => {\n  config.labels.released = {\n    name: 'released',\n    description: 'This issue/pull request has been released'\n  };\n\n  return config;\n});\n```\n\n#### beforeShipIt\n\nHappens before `shipit` is run. This is a great way to throw an error if a token or key is not present.\n\n```ts\nauto.hooks.beforeRun.tapPromise('NPM', async config => {\n  if (!process.env.NPM_TOKEN) {\n    throw new Error('NPM Token is needed for the NPM plugin!');\n  }\n});\n```\n\n#### beforeCommitChangelog\n\nRan before the `changelog` command commits the new release notes to `CHANGELOG.md`.\nUseful for modifying the changelog as a whole or creating extra `changelog` files. These files can be apart of the commit that updates the changelog.\n\n- bump - the semver bump\n- commits - the commits in the changelog\n- currentVersion - version that was just released\n- lastRelease - the version before the current version\n- releaseNotes - generated release notes for the release\n\n```ts\nauto.hooks.beforeCommitChangelog.tap(\n  'MyPlugin',\n  async ({ currentVersion, commits, releaseNotes, lastRelease }) => {\n    // do something\n  }\n);\n```\n\n#### afterAddToChangelog\n\nRan after the `changelog` command adds the new release notes to `CHANGELOG.md`.\nUseful for getting extra commits into a release before publishing.\n\n- bump - the semver bump\n- commits - the commits in the changelog\n- currentVersion - version that was just released\n- lastRelease - the version before the current version\n- releaseNotes - generated release notes for the release\n\n```ts\nauto.hooks.afterAddToChangelog.tap(\n  'MyPlugin',\n  async ({ currentVersion, commits, releaseNotes, lastRelease }) => {\n    // do something\n  }\n);\n```\n\n#### afterRelease\n\nRan after the `release` command has run. This hooks gets the following arguments:\n\n- version - version that was just released\n- commits - the commits in the release\n- releaseNotes - generated release notes for the release\n- response - the response returned from making the release\n\n```ts\nauto.hooks.afterRelease.tap(\n  'MyPlugin',\n  async ({ version, commits, releaseNotes, response }) => {\n    // do something\n  }\n);\n```\n\n#### afterShipIt\n\nRan after the `shipit` command has run.\n\n#### getAuthor\n\nGet git author. Typically from a package distribution description file.\n\n```ts\nauto.hooks.getAuthor.tapPromise('NPM', async () => {\n  const { author } = JSON.parse(await readFile('package.json', 'utf-8'));\n\n  if (author) {\n    return author;\n  }\n});\n```\n\n#### getPreviousVersion\n\nGet the previous version. Typically from a package distribution description file.\n\n```ts\nauto.hooks.getPreviousVersion.tapPromise('NPM', async prefixRelease => {\n  const { version } = JSON.parse(await readFile('package.json', 'utf-8'));\n\n  if (version) {\n    return prefixRelease(\n      JSON.parse(await readFile('package.json', 'utf-8')).version\n    );\n  }\n});\n```\n\n#### getRepository\n\nGet owner and repository. Typically from a package distribution description file.\n\n```ts\nauto.hooks.getRepository.tapPromise('NPM', async () => {\n  const owner = // get the owner from package.json\n  const repo = // get the repo from package.json\n\n  return {\n    owner,\n    repo\n  }\n});\n```\n\n#### onCreateRelease\n\nTap into the things the Release class makes. This isn't the same as `auto release`, but the main class that does most of the work.\n\nAvailable hooks:\n\n- onCreateLogParse (detailed [below]())\n- onCreateChangelog (detailed [below]())\n\n```ts\nthis.hooks.onCreateRelease.tap('MyPlugin', release => {\n  release.hooks.onCreateLogParse.tap('Change log parseing', logParse =>\n    // extend logParse\n  );\n\n  release.hooks.onCreateChangelog.tap(\n    'Change changelog',\n    changelog => {\n      // extend changelog\n    }\n  );\n});\n```\n\n#### onCreateChangelog\n\nThis is where you hook into the changelog's hooks. See usage [below](#changelog-hooks). This hook is exposed for convenience on during `this.hooks.onCreateRelease` and at the root `this.hooks`\n\n#### onCreateLogParse\n\nThis is where you hook into the LogParse's hooks. See usage [below](#logparse-hooks). This hook is exposed for convenience on during `this.hooks.onCreateRelease` and at the root `this.hooks`\n\n#### version\n\nVersion the package. This is a good opportunity to `git tag` the release also. Here `npm` does it for us.\n\n```ts\nauto.hooks.version.tapPromise('NPM', async (version: SEMVER) => {\n  await execPromise('npm', [\n    'version',\n    version,\n    '-m',\n    'Bump version to: %s [skip ci]'\n  ]);\n});\n```\n\n#### afterVersion\n\nRan after the package has been versioned.\n\n#### publish\n\nPublish the package to some package distributor. You must push the tags to github!\n\n```ts\nauto.hooks.publish.tapPromise('NPM', async (version: SEMVER) => {\n  await execPromise('npm', [\n    'version',\n    version,\n    '-m',\n    'Bump version to: %s [skip ci]'\n  ]);\n  await execPromise('npm', ['publish']);\n  await execPromise('git', [\n    'push',\n    '--follow-tags',\n    '--set-upstream',\n    'origin',\n    '$branch'\n  ]);\n});\n```\n\n#### afterPublish\n\nRan after the package has been published.\n\n---\n\n#### canary\n\nUsed to publish a canary release. In this hook you get the semver bump and the unique canary postfix ID.\n\n```ts\nauto.hooks.canary.tapPromise(this.name, async (version, postFix) => {\n  const lastRelease = await auto.git!.getLatestRelease();\n  const current = await auto.getCurrentVersion(lastRelease);\n  const nextVersion = inc(current, version as ReleaseType);\n  const isScopedPackage = name.match(/@\\S+\\/\\S+/);\n  const canaryVersion = `${nextVersion}-canary${postFix}`;\n\n  await execPromise('npm', ['version', canaryVersion, '--no-git-tag-version']);\n  await execPromise('npm', ['publish', '--tag', 'canary']);\n\n  auto.logger.verbose.info('Successfully published canary version');\n  return canaryVersion;\n});\n```\n\n### Changelog Hooks\n\n#### addToBody\n\nAdd extra content to your changelogs.\nThis hook provide all the current \"extra\" notes and all of the commits for the changelog.\nYou must return the notes array.\n\nThe following adds a random GIF from [giphy](https://giphy.com) to each new changelog.\n\n```ts\nauto.hooks.onCreateChangelog.tapPromise('Giphy', changelog =>\n  changelog.hooks.renderChangelogLine.tapPromise(\n    'Giphy',\n    async (notes, commits) => {\n      const response = await fetch(`https://api.giphy.com/v1/gifs/random?api_key=${process.env.GIPHY_KEY}`);\n      const json = await response.json();\n      const { data: gif } = json;\n\n      return [...notes, `![${gif.title}](${gif.url})\\n`]\n    }\n  );\n);\n```\n\n#### renderChangelogLine\n\nChange how the changelog renders lines. This hook provides the commit and the current state of the line render. You must return the commit and the line string state as a tuple ([commit, line]).\n\nThe following plugin would change all the bullet points in the changelog to star emojis.\n\n```ts\nauto.hooks.onCreateChangelog.tapPromise('Stars', changelog =>\n  changelog.hooks.renderChangelogLine.tapPromise(\n    'Stars',\n    async (commit, line) =>\n      [commit, `${line.replace('-', ':star:')}\\n`]\n  );\n);\n```\n\n#### renderChangelogTitle\n\nChange how the changelog renders titles. The hook provides the current label for the section and all the configured changelog titles.\n\n```ts\nauto.hooks.onCreateChangelog.tapPromise('Stars', changelog =>\n  changelog.hooks.renderChangelogTitle.tap(\n    'My Titles',\n    (label, changelogTitles) => `:heart: ${changelogTitles[label]} :heart:`\n  );\n);\n```\n\n#### renderChangelogAuthor\n\nChange how the changelog renders authors. This is both the author on each commit note and the user in the author section (the part between parentheses). This is generally a link to some profile.\n\n```ts\nauto.hooks.onCreateChangelog.tapPromise('Stars', changelog =>\n  changelog.hooks.renderChangelogAuthor.tap(\n    'test',\n    (author, commit) => `:heart: ${author.name}/${commit.authorEmail} :heart:`\n  );\n);\n```\n\n#### renderChangelogAuthorLine\n\nChange how the changelog renders authors in the authors section. The hook provides the author object and the user created with `renderChangelogAuthor`. Here is where you might display extra info about the author, such as their full name.\n\n```ts\nauto.hooks.onCreateChangelog.tapPromise('Stars', changelog =>\n  changelog.hooks.renderChangelogAuthorLine.tap(\n    'test',\n    (author, user) => `:shipit: ${author.name} (${user})\\n`\n  );\n);\n```\n\n#### createChangelogTitle\n\nControl the titles in the `CHANGELOG.md`\n\n```ts\n// Render only the date in the title\nauto.hooks.onCreateRelease.tap(this.name, release => {\n  release.hooks.createChangelogTitle.tap(\n    `${this.name} - lerna independent`,\n    () => ''\n  );\n});\n```\n\n---\n\n#### omitReleaseNotes\n\nControl what commits effect the additional release notes section.\n\n```ts\nauto.hooks.onCreateChangelog.tap(this.name, changelog => {\n  changelog.hooks.omitReleaseNotes.tap(this.name, commit =>\n    commit.subject.includes('WIP')\n  );\n});\n```\n\n---\n\n### LogParse Hooks\n\n#### parseCommit\n\nParse information about a commit from a commit. Here is where `auto` gets the PR number from the merge commits.\n\n```ts\nauto.hooks.onCreateLogParse.tapPromise('Stars', logParse =>\n  logParse.hooks.parseCommit.tap(\n    'test',\n    (commit) => {\n      const bump = getBump(commit.subject, logParse.options.versionLabels);\n      commit.labels = [bump]\n      return commit;\n    }\n  );\n);\n```\n\n#### omitCommit\n\nChoose to omit certain commits. If you return true the commit will be omitted. Be sure to return nothing if you don't want the commit omitted.\n\n```ts\nauto.hooks.onCreateLogParse.tapPromise('Stars', changelog =>\n  changelog.hooks.omitCommit.tap(\n    'test',\n    (commit) => {\n      if (someTest(commit.subject)) {\n        return true;\n      }\n    }\n  );\n);\n```\n\n## Example Plugin - NPM (simple)\n\nTo create a plugin simply make a class with an `apply` method and tap into the hooks you need.\n\n```ts\nimport * as fs from 'fs';\nimport { promisify } from 'util';\n\nimport { IAutoHooks, Auto, SEMVER, execPromise } from 'auto';\nimport getConfigFromPackageJson from './package-config';\n\nconst readFile = promisify(fs.readFile);\n\nexport default class NPMPlugin {\n  public apply(auto: Auto) {\n    auto.hooks.getAuthor.tapPromise('NPM', async () => {\n      const { author } = JSON.parse(await readFile('package.json', 'utf-8'));\n\n      if (author) {\n        auto.logger.log.info('NPM: Got author information from package.json');\n        return author;\n      }\n    });\n\n    auto.hooks.getPreviousVersion.tapPromise('NPM', async prefixRelease => {\n      const { version } = JSON.parse(await readFile('package.json', 'utf-8'));\n\n      auto.logger.log.info(\n        'NPM: Got previous version from package.json - ',\n        version\n      );\n\n      if (version) {\n        return prefixRelease(\n          JSON.parse(await readFile('package.json', 'utf-8')).version\n        );\n      }\n    });\n\n    auto.hooks.getRepository.tapPromise('NPM', async () => {\n      auto.logger.log.info('NPM: getting repo information from package.json');\n      return getConfigFromPackageJson();\n    });\n\n    auto.hooks.publish.tapPromise('NPM', async (version: SEMVER) => {\n      await execPromise('npm', [\n        'version',\n        version,\n        '-m',\n        'Bump version to: %s [skip ci]'\n      ]);\n      await execPromise('npm', ['publish']);\n      await execPromise('git', [\n        'push',\n        '--follow-tags',\n        '--set-upstream',\n        'origin',\n        '$branch'\n      ]);\n    });\n  }\n}\n```\n"}];e.default=o,n.exports=e.default}}]);
//# sourceMappingURL=search-files.js.map